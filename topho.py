# %%
from pathlib import Path
from utils import *
import sys

# %%
import argparse
import shutil
import subprocess
from ctypes import windll

SCRIPTDIR = Path(__file__).parent
START_TIME = HandyTime(datetime.now())

def positive_int(s):
    try:
        x = int(s)
        assert x > 0
        return x
    except:
        raise argparse.ArgumentTypeError(f"invalid positive int value: '{s}'")

def existing_directory(s):
    try:
        path = Path(s)
        assert path.exists() and path.is_dir()
        return path
    except:
        raise argparse.ArgumentTypeError(f"non existing directory: '{s}'")

def existing_directory_or_archive(s):
    path = Path(s)
    if not path.exists():
        raise argparse.ArgumentTypeError(f"non existing source: '{s}'")

    if path.is_dir():
        return ('dir', path)

    if path.suffix[1:] in ARXIV_EXTS and os.access(path, os.R_OK):
        return ('arx', path)

    raise argparse.ArgumentTypeError(f"source is neither directory or reable archive file: '{s}'")

def existing_readable_file(s):
    if s == '-': return '-'
    try:
        path = Path(s)
        assert not path.is_dir()
        assert path.exists() and os.access(s, os.R_OK)
        return path
    except:
        raise argparse.ArgumentTypeError(f"not a readable file: '{s}'")

def writable_file(s):
    if s == '-': return '-'
    try:
        path = Path(s)
        assert not path.is_dir()
        assert not path.exists() or os.access(s, os.W_OK)
        return path
    except:
        raise argparse.ArgumentTypeError(f"not a writable path: '{s}'")

def executable(s):
    try:
        ss = shutil.which(s); assert ss
        path = Path(ss); assert path.exists() and not path.is_dir()
        #assert os.access(path, os.X_OK); shutil.which already checked X_OK
        # but still non-executable files could have X_OK.. for some reason :P

        # proc = subprocess.Popen([str(path), '-V'], stdout=subprocess.PIPE)
        # stdout, _ = proc.communicate(timeout=1)
        # proc.kill()
        # assert stdout.startswith(b'mpv ')

        return path
    except:
        raise argparse.ArgumentTypeError(f"not a valid mpv executable: '{s}'")

# Handy* formatters are statically error checked. <- run once, run always.

# furthermore, all the characters generated by Handy*.__format__ is either a digit, alphabet,
# one of "+-T:", slice of given string or thoes already present in format string.
# only valid fileapth (source_dir and filenames) are given as string, already being valid path-characters.
# characters in format string are easily validated in static time.
# any other characters (alphanum +-T:) are also valid path-characters.

# also, since '/', '\' can only come from format string literals, it is easy to check if there
# is directory-change-injection
def nameformat(s):
    if '/' in s or '\\' in s: # if we verify there's no '/' or '\', we can be sure'
        raise argparse.ArgumentTypeError("can't use '\\' or '/' in filenames")
    try:
        ret = s.format( # generate with random
            index = HandyInt(1),
            name = HandyString("Bapanada"),
            hier = HandySlice(["this", "dir"]),
            size = 3012,
            created  = HandyTime(datetime(1970,1,3).astimezone()),
            modified = HandyTime(datetime(1970,1,3).astimezone()),
            accessed = HandyTime(datetime(1970,1,3).astimezone()),
            dup = HermitDup(1),
        )
        return s
    # KeyError when accessing non-existing variable
    # AttributeError when accessing invalid attr of HandyTime
    # ValueError for any other formatting error
    except KeyError as e:
        raise argparse.ArgumentTypeError(f"no variable named {str(e)} provided")
    except (AttributeError, ValueError) as e:
        raise argparse.ArgumentTypeError(str(e))
    except Exception as e:
        # other kind of exceptions are an error in the code not namestr
        # but argparse catches them all and hide the message.
        # so we print it here for debugging purpose
        print("BUG! report to the developer!", repr(e))
        raise e

# https://stackoverflow.com/a/52025430
class RawTextArgumentDefaultsHelpFormatter(
        argparse.ArgumentDefaultsHelpFormatter,
        argparse.RawTextHelpFormatter
    ):
        pass

parser = argparse.ArgumentParser(prog='Topho',
    formatter_class=RawTextArgumentDefaultsHelpFormatter,
    description='Minimallistic utility for manual image organizing',
    epilog='''
NAMEF:
    You can describe new name for moved file using python style formating.
    For example, giving --name_format="{index}th-image-{name}__{size}bytes"
    converts "nyancat.gif" to "1th-image-nyancat__1038bytes.gif".
    See following sections for available formatting options and variables.

NAMEF variables:
    index    :int  - enumeration, starting from 0
    name     :str  - original name of the file
    size     :int  - size of the file in bytes
    hier     :slice- list of parent directories from source_dir, inclusive
    created  :time - file creation time
    modified :time - file modification time
    accessed :time - file access time
    dup      :dup  - enumeration among duplicated names, starting from 0

NAMEF formatting:
    Before anything, note that only attribute access is allowed for variables,
    which means "{index*2}" is cannot be done. So we provide some attribute
    extension for ease of handling variables.

    For integer type, additional arithmetic attributes are provided as well
    as basic integer formatting syntax. You can do (asssuming index=9)
    - .p<n>, .t<n> for addition
      "{index.p20}" == '29'
    - .m<n> for subtraction
      "{index.m10}" == '-1'
    - .x<n>, .X<n> for multiplication
      "{index.x3}" == '27'
    - .d<n> for integer division
      "{index.d2}" == '4'
    - mixture of all
      "{index.p3.x2.4}" == '6'
    - with integer format_spec
      "{index.p3.x2.4:+03}" == '+006'

    For slice type, start-end slicing attributes are provided. format spec can be
    preceded with a seperator as '<sep>!<spec>' which will be used to join slice elements.
    If spereator is omitted, it defaults to '' or '\\' for 'hier' variable.
    <spec> is basic python formatter, applys element-wisely. Each formatted result
    then joined by <sep>. string types are simliar to slice type but <spec> applys to
    the whole string. You can do (assuming name=asdf)
    - ._<n> for starting index, same as str[n:]
      "{slice._2}" == 'df'
    - .__<m> for ending index, same as str[:m]
      "{slice.__3}" == 'asd'
    - ._<n>_<m> to take range [n, m), same as str[n:m]
      "{name._1_3}" == 'sd'
    - indexing from behind, use 'm' prefix instead of '-' to indicate negative
      "{name._1_m1}" == 'sd'
    - complex mixture example
      "=={name._3:#^7}---" == '==##asd##---'

    'hier' is slice variable consisting of directory names from source_dir to
    the file. '' element is at the end to add trailing seperator.
    Assume source_dir = 'images' and filepath is 'images\source\dir\y.png', then
    hier == ['images', 'source', 'dir', ''] and name == y.png,
    - simpy using with {name} to get filepath (from source_dir)
      "{hier}{name}" == 'images\source\dir\y.png'
    - use custome seperator with custom elem-wize formatting
      "{hier:-!:_<5}{name}" == 'images-source-dir__-y.png'
    - remove trailing seperator by slicing
      "{hier._1_m1}_{name}" == 'source\dir_y.png'

    For time types, you can use strftime format in format_spec region.
    See https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
    for more detailed explanations. Examples follows..
    - default formatting shows iso-8601 date
      "{created}" == '2022-08-02'
    - by specifying 'iso' as format you get full iso-8601 representation
      "{created:iso}" == '2022-08-02T07-23-45+0900'
    - accessing 'utc' attribute gives datetime in UTC
      "{created.utc:iso}" == '2022-08-01T22-23-45+0000'
    - all attributes of python datatime struct supported
      "{created.day:03}" == '002'
    - strftime style formatting
      "{created:%Y_%S}" == '2022_45'

    'dup' type is similar to 'int' type, all arithmetic attbributes are
    provided but has extended format spec. Normal integer format spec
    is may preceeded by enclosure specifier of format "<prefix>!<suffix>!".
    If enclosure specifier exists dup acts in hermit mode, expose itself
    (and enclosure) only if dup > 0.
    For example, if there are only 1 file created on 2022-08-02, the
    formatstring "{created}{dup.x2.m2:==(!)!0^3}" simply yields '2022-08-02'.
    But if there are 4 of them, they will be renamed as (in sorted order)
    '2022-08-02==(-20)', '2022-08-02', '2022-08-02==(020)' '2022-08-02==(040)'.
    Note that hermit mode depends on result 'dup.x2.m2' not the original 'dup'.
    If format_spec is empty, you can omit trailing '!', like "{dup:(!)}"
''')

parser.add_argument('source', type=existing_directory_or_archive,
    help='path of image directory to organize or an archive file')
parser.add_argument('target_dir', type=Path, default=None, nargs='?',
    help='path of directory to store organized images, defaults to current directory, created if not exists')
    #nargs='?' makes this positional argument optional https://stackoverflow.com/a/4480202
parser.add_argument('--version', '-v', action='version', version=f'%(prog)s {VERSION}')
parser.add_argument('--dry', '-n', dest='dry', action='store_true',
    help="don't actually move files, only pretend organizing")
parser.add_argument('--keep', '--copy', dest='keep', action='store_true',
    help="keep the original files (copy, not move)")
parser.add_argument('--maxw', type=positive_int, default=int(windll.user32.GetSystemMetrics(0)*0.8),
    help='maximum width of image, defaults to screen width * 0.8')
parser.add_argument('--maxh', type=positive_int, default=int(windll.user32.GetSystemMetrics(1)*0.8),
    help='maximum height of image, defaults to screen height * 0.8')
parser.add_argument('--name_format', type=nameformat, metavar='NAMEF', default='{hier._1}{name}',
    help="python style formatstring for moved file names, see <NAMEF> section")
parser.add_argument('--test_names', type=Path, nargs='*',
    help='if provided, apply name_format on this filename, print then exits')
parser.add_argument('--logfile', type=writable_file, default=f"topholog_{START_TIME:iso}.txt",
    help='path to log file where unmoved file list will be written')
parser.add_argument('--mpv', type=executable, metavar='MPVPATH', default="mpv.exe",
    help='path to invoke mpv player executable')
    # '--mpv mpv' resolved to 'mpv.COM' which prints some info to stdout by default
    # while 'mpv.exe' doesn't.
parser.add_argument('--arx', type=executable, metavar='ARXPATH', default="Bandizip.exe",
    help='path to invoke un-archive files')
parser.add_argument("--filesystem_latency", type=float, metavar='FSLAT', default=0.01,
    help='time to wait after filesystem operation like mkdir')
parser.add_argument('--retry', type=existing_readable_file, metavar='LOGFILE',
    help='')
parser.add_argument('--frontq_min', type=positive_int, metavar='FQm', default=3,
    help='minimum # of images pre-loaded, increase if forward loading is too slow')
parser.add_argument('--frontq_max', type=positive_int, metavar='FQM', default=10,
    help='maximum # of images kept loaded when un-doing, increase if you frequently undo & redo')
parser.add_argument('--backq_min',  type=positive_int, metavar='BQm', default=3,
    help='minimum # of images loaded for un-doing, increase if backward loading is too slow')
parser.add_argument('--backq_max',  type=positive_int, metavar='BQM', default=5,
    help='maximum # of images kept loaded after organizing, increase if you frequently undo & redo')
args = parser.parse_args()
#args = parser.parse_args(["images.zip", "this/dir", "--name_format", "{hier._1}{name}"])


# %%

import tempfile

if args.test_names:
    source_dir = args.source[1]
    virtual_files = set()
    if args.target_dir is None or not args.target_dir.exists():
        outdir = Path('.')
        exists = lambda p: p in virtual_files
    else:
        if not args.target_dir.is_dir():
            print(f"target_dir '{args.target_dir}' is not a directory")
        outdir = args.target_dir
        exists = lambda p: p.exists() or p in virtual_files

    for i, test_name in enumerate(args.test_names):
        test_path = source_dir / test_name
        ret, _ = format_name(args.name_format, i, test_path, source_dir, outdir, exists=exists)
        virtual_files.add(ret)
        print(ret)

    sys.exit(0)


# %%
if args.retry:
    if args.retry == '-':
        remaining, cwd, args_ = load_remainings(sys.stdin)
    else:
        with open(args.retry, "rt") as f:
            remaining, cwd, args_ = load_remainings(f)
    
    args_.dry = args.dry
    args_.logfile = args.logfile.absolute()
    args_.filesystem_latency = args.filesystem_latency

    os.chdir(cwd)

    result = []
    for reason, idx, dup, path, dir, note in remaining:
        result.append((idx, (path, dir))) # dup, reason, note ignored.

    source_dir = args_.source

    # FIXME temp_dir=None (consider source_dir is not temporary) 
    # then ignored_files=[] is never used anyway and source_dir will not be removed
    # this is error-prone interface, need to change later
    organize(result, args_, source_dir, None, [], START_TIME)

    sys.exit(0)


# %%
if args.target_dir is None:
    args.target_dir = Path('.')

if args.source[0] == 'dir':
    temp_dir = None
    source_dir = args.source[1]
else:
    temp_dir = Path(tempfile.mkdtemp(prefix=str(args.source[1]), dir='.'))
    arx_proc = subprocess.Popen([str(args.arx), 'x', '-target:name', args.source[1], str(temp_dir)])
    source_dir = temp_dir / args.source[1].stem


# %%
view = OrganHelperView(args.maxw, args.maxh, str(args.mpv), SCRIPTDIR)

if temp_dir is not None:
    arx_proc.wait()

KNOWN_EXTS = VIDEO_EXTS | IMAGE_EXTS
supported_files = list(
    (path, None)
    for path
    in source_dir.glob('**/*')
    if not path.is_dir() and path.suffix[1:] in KNOWN_EXTS
)

ignored_files = list(
    path
    for path
    in source_dir.glob('**/*')
    if not path.is_dir() and not path.suffix[1:] in KNOWN_EXTS
)

view.load(supported_files, (args.frontq_min, args.frontq_max, args.backq_min, args.backq_max))

result = view.run()
result = list(enumerate(result))

# %%

if not view.commit:
    print("no commit, nothing happed!")
    if temp_dir is not None:
        shutil.rmtree(temp_dir)
    sys.exit()

organize(result, args, source_dir, temp_dir, ignored_files, START_TIME)